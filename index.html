<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Leitor de Tags RFID</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: "Inter", sans-serif;
    }
    .custom-scrollbar::-webkit-scrollbar {
      width: 8px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.3);
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-6">
  <div class="bg-white rounded-2xl shadow-lg p-10 md:p-14 max-w-lg w-full text-center">
    <h1 class="text-4xl md:text-5xl font-extrabold mb-6 text-indigo-800 drop-shadow-md">
      Leitor de Tags RFID
    </h1>
    <p class="text-2xl md:text-3xl text-gray-700 mb-8">
      Última Tag Lida:
      <span id="tagAtual" class="font-bold text-green-600 text-5xl md:text-6xl block mt-2">
        Aguardando Tag...
      </span>
    </p>
    <div id="statusMessage" class="mt-4 text-lg font-medium text-gray-500"></div>
  </div>

  <script>
    const tagElement = document.getElementById('tagAtual');
    const statusMessageElement = document.getElementById('statusMessage');
    const API_URL = 'https://iot-teste.onrender.com/api/latest-tag';
    const FETCH_INTERVAL_MS = 1000;

    // Variável para armazenar a última tag exibida
    let lastDisplayedTag = null;
    // Variável para controlar se houve um erro de conexão recente
    let connectionErrorOccurred = false;

    function updateUI(text, colorClass, statusText, statusColorClass) {
      tagElement.textContent = text;
      tagElement.classList.remove('text-green-600', 'text-red-600', 'text-orange-600');
      tagElement.classList.add(colorClass);

      statusMessageElement.textContent = statusText;
      statusMessageElement.classList.remove('text-gray-500', 'text-red-500', 'text-green-500');
      statusMessageElement.classList.add(statusColorClass);
    }

    async function fetchTag() {
      try {
        // Só mostra "Buscando..." se for a primeira vez ou se houve um erro de conexão anterior
        if (lastDisplayedTag === null || connectionErrorOccurred) {
            updateUI('Buscando...', 'text-orange-600', 'Conectando à API...', 'text-gray-500');
        }

        const res = await fetch(API_URL);
        connectionErrorOccurred = false; // Resetar o flag de erro se a requisição foi bem-sucedida

        if (!res.ok) {
          const errorBody = await res.text();
          throw new Error(`Erro HTTP ${res.status}: ${res.statusText}. Detalhes: ${errorBody.substring(0, 100)}...`);
        }

        const contentType = res.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          const textResponse = await res.text();
          throw new Error(`Resposta inesperada. Esperado JSON, mas recebeu "${contentType || 'Nenhum'}". Conteúdo: ${textResponse.substring(0, 100)}...`);
        }

        const data = await res.json();
        const currentTag = data.tagId; // A tag atual recebida da API

        // Compara a tag atual com a última tag exibida
        if (currentTag !== lastDisplayedTag) {
          if (currentTag) {
            updateUI(currentTag, 'text-green-600', 'Nova tag lida com sucesso!', 'text-green-500');
          } else {
            // Se a API retornar null (nenhuma tag lida ainda) e for diferente da última exibida
            updateUI('Nenhuma tag lida ainda.', 'text-orange-600', 'API conectada, aguardando tags...', 'text-gray-500');
          }
          lastDisplayedTag = currentTag; // Atualiza a última tag exibida
        } else {
          // Se a tag for a mesma, apenas mantém o status da mensagem
          if (currentTag) {
              statusMessageElement.textContent = 'Aguardando nova tag...';
              statusMessageElement.classList.remove('text-red-500', 'text-orange-500');
              statusMessageElement.classList.add('text-green-500');
          } else {
              statusMessageElement.textContent = 'API conectada, aguardando tags...';
              statusMessageElement.classList.remove('text-red-500', 'text-green-500');
              statusMessageElement.classList.add('text-gray-500');
          }
        }

      } catch (err) {
        // Em caso de erro, exibe a mensagem de erro e seta o flag
        connectionErrorOccurred = true;
        updateUI('Erro de Conexão!', 'text-red-600', `Não foi possível conectar à API: ${err.message}`, 'text-red-500');
        console.error("Erro ao buscar tag:", err);
        lastDisplayedTag = null; // Reinicia a última tag para forçar "Buscando..." na próxima tentativa de sucesso
      }
    }

    // Define um intervalo para atualizar a tag
    setInterval(fetchTag, FETCH_INTERVAL_MS);
    // Chama a função uma vez imediatamente ao carregar a página
    fetchTag();
  </script>
</body>
</html>
