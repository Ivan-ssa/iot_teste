#include <SPI.h>       // Biblioteca para comunicação SPI (usada pelo RC522)
#include <MFRC522.h>   // Biblioteca para o módulo RFID RC522
#include <WiFi.h>      // Biblioteca para comunicação Wi-Fi no ESP32
#include <HTTPClient.h> // Biblioteca para fazer requisições HTTP

// Definições dos pinos GPIO do ESP32 conectados ao módulo RC522:
// ESP32 -- RC522
// D21   -- SDA (também conhecido como SS/CS - Slave Select/Chip Select)
// D22   -- RST (Reset)
#define SS_PIN    21 // Pino conectado ao pino SDA (ou CS) do RC522.
#define RST_PIN   22 // Pino conectado ao pino RST do RC522.

// Pino do LED interno do ESP32 (geralmente GPIO2)
#define LED_INTERNO_ESP32 2

// Configurações de Wi-Fi - VOCÊ DEVE SUBSTITUIR ESTES VALORES
const char* ssid = "SEU_SSID";         // Seu nome de rede Wi-Fi (SSID)
const char* password = "SUA_SENHA_WIFI"; // Sua senha de rede Wi-Fi

// URL da sua API Node.js no Render.com.
// CERTIFIQUE-SE DE USAR A URL CORRETA DA SUA API
const char* apiHost = "https://iot-teste.onrender.com";
// O endpoint para onde o ESP32 enviará o UID da tag
const char* apiEndpoint = "/tag";

// Cria uma instância do objeto MFRC522, passando os pinos SS e RST.
MFRC522 mfrc522(SS_PIN, RST_PIN);

// Função auxiliar para converter o UID (array de bytes) da tag em uma string hexadecimal
String uidToHexString(byte *uid, byte uidLength) {
  String uidString = "";
  for (byte i = 0; i < uidLength; i++) {
    if (uid[i] < 0x10) { // Se o byte for menor que 16 (em hexadecimal), adiciona um '0' na frente
      uidString += "0";
    }
    uidString += String(uid[i], HEX); // Converte o byte para sua representação hexadecimal
  }
  uidString.toUpperCase(); // Converte a string para letras maiúsculas (opcional, mas bom para padronização)
  return uidString;
}

void setup() {
  // Inicia a comunicação serial para debug
  Serial.begin(115200);
  while (!Serial); // Espera a porta serial estar pronta (útil para algumas placas)

  // 1. Conecta ao Wi-Fi
  Serial.print("Conectando ao WiFi ");
  Serial.println(ssid);
  WiFi.begin(ssid, password); // Inicia a conexão Wi-Fi
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) { // Tenta conectar por até 10 segundos (20 * 500ms)
    delay(500);
    Serial.print(".");
    attempts++;
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi conectado!");
    Serial.print("Endereço IP: ");
    Serial.println(WiFi.localIP()); // Exibe o IP local do ESP32
  } else {
    Serial.println("\nFalha na conexão WiFi. Verifique as credenciais e reinicie o ESP32.");
  }

  // 2. Inicia a interface SPI e o módulo MFRC522
  SPI.begin();       // Inicia a comunicação SPI
  mfrc522.PCD_Init(); // Inicializa o módulo RC522

  // 3. Configura o LED interno do ESP32
  pinMode(LED_INTERNO_ESP32, OUTPUT);
  digitalWrite(LED_INTERNO_ESP32, LOW); // Garante que o LED esteja desligado no início

  Serial.println("=========================================");
  Serial.println("RFID RC522 e ESP32 - Leitor de Tags");
  Serial.println("Aproxime o seu cartao ou chaveiro RFID...");
  Serial.println("=========================================");
}

void loop() {
  // 1. Verifica se há uma nova tag presente OU se consegue ler a serial (UID) da tag.
  // Se não houver, ou se a leitura falhar, desliga o LED e retorna.
  if (!mfrc522.PICC_IsNewCardPresent() || !mfrc522.PICC_ReadCardSerial()) {
    digitalWrite(LED_INTERNO_ESP32, LOW); // Desliga o LED
    return; // Sai da função loop e tenta novamente
  }

  // 2. Se a tag foi lida com sucesso, acende o LED
  digitalWrite(LED_INTERNO_ESP32, HIGH);

  // 3. Converte o UID da tag (que é um array de bytes) para uma string hexadecimal
  String tagUID = uidToHexString(mfrc522.uid.uidByte, mfrc522.uid.size);
  Serial.print("Tag UID (HEX): ");
  Serial.println(tagUID); // Exibe o UID no Serial Monitor

  // 4. Envia o UID da tag para a API via HTTP POST
  if (WiFi.status() == WL_CONNECTED) { // Verifica se o Wi-Fi está conectado
    HTTPClient http; // Cria um objeto HTTPClient
    String serverPath = String(apiHost) + String(apiEndpoint); // Monta a URL completa da API

    http.begin(serverPath.c_str()); // Inicia a conexão HTTP
    http.addHeader("Content-Type", "application/json"); // Define o cabeçalho Content-Type como JSON

    // Monta o corpo da requisição JSON, contendo o ID da tag
    String httpRequestData = "{\"tagId\":\"" + tagUID + "\"}";
    Serial.print("Enviando para API: ");
    Serial.println(httpRequestData);

    // Faz a requisição POST e obtém o código de resposta HTTP
    int httpResponseCode = http.POST(httpRequestData);

    if (httpResponseCode > 0) { // Se o código de resposta for positivo (ex: 200 OK)
      Serial.printf("[HTTP] Código de resposta: %d\n", httpResponseCode);
      String responsePayload = http.getString(); // Obtém a resposta do servidor
      Serial.println(responsePayload); // Exibe a resposta no Serial Monitor
    } else { // Se houve um erro na requisição HTTP
      Serial.printf("[HTTP] Erro na requisição: %s\n", http.errorToString(httpResponseCode).c_str());
    }
    http.end(); // Fecha a conexão HTTP e libera os recursos
  } else {
    Serial.println("Wi-Fi desconectado. Não foi possível enviar a tag para a API.");
  }

  // Pequeno atraso para o LED ficar aceso e para evitar múltiplas leituras muito rápidas da mesma tag
  delay(1000); // Mantém o LED aceso por 1 segundo
